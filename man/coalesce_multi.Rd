% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coalesce_multi.R
\name{coalesce_multi}
\alias{coalesce_multi}
\title{Coalesce Multiple Columns}
\usage{
coalesce_multi(df, pattern = stringr::fixed("."), noisy = TRUE)
}
\arguments{
\item{df}{a data frame}

\item{pattern}{pattern to split column names along using \code{stringr::str_split_fixed}}

\item{noisy}{Do you want messages about the columns being coalesced?}
}
\value{
a data frame with coalesced columns
}
\description{
Coalesce columns matching the LHS when splitting by \code{pattern}. Columns
are coalesced from left to right as they appear in \code{df}
}
\note{
Columns that do not contain \code{pattern} but match another column after splitting
will STILL be coalesced. In the example, the columns \code{c(value, value.x, value.y)} are
coalesced when \code{(pattern = stringr::fixed('.')}.
}
\examples{
# Let's say you have two two data sets about birds
# and you want to combine them to make a more complete version
# while prioritizing the woods data over the feeder data
woods = tibble::tibble(
  bird = c('Northern Flicker', 'Chesnut-backed Chickadee', 'California Quail'),
  group_size = c(NA, NA, 2L),
  food = c('bugs', NA, 'seeds')
)

feeder = tibble::tibble(
  bird = c('Northern Flicker','Chesnut-backed Chickadee', 'Evening Grosbeak'),
<<<<<<< HEAD
  group_size = c(1L, 8L, 13L),
=======
  group_size = c(1L, 8L, 20L),
>>>>>>> b6547dc62c1b16e30a78a18dab2317ab0b586df5
  food = c('seeds', NA, NA)
)

# See what they look like when joined on "bird"
dplyr::full_join(
  x = woods,
  y = feeder,
  by = 'bird'
)

# When we coalesce multi, it first looks for non-missing values
# from the woods (.x) and then from the feeder (.y):
dplyr::full_join(
  x = woods,
  y = feeder,
  by = 'bird'
) |>
  coalesce_multi()

# Note that it can coalesce values with
# different separators and even no suffix:
dplyr::full_join(
  x = woods,
  y = feeder,
  by = 'bird',
  suffix = c('', '~feeder')
) |>
  coalesce_multi(pattern = '~')
}
